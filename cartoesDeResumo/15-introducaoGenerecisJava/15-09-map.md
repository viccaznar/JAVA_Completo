# Cart√µes de Resumo: Map em Java üó∫Ô∏èüîë

  O *Map* √© uma estrutura de dados poderosa em Java que armazena pares chave/valor, permitindo acesso r√°pido e opera√ß√µes eficientes. Essa cole√ß√£o √© amplamente utilizada para modelar dados onde cada chave √© √∫nica.


## 1. Conceito e Caracter√≠sticas do Map

  - **Defini√ß√£o:**  

    Um `Map<K, V>` √© uma cole√ß√£o de pares chave/valor. Cada chave √© √∫nica e os elementos s√£o indexados por elas, n√£o possuindo, portanto, uma posi√ß√£o fixa.


  - **Principais Caracter√≠sticas:**  


    - **Sem Duplicatas:** N√£o admite repeti√ß√µes das chaves.


    - **Acesso R√°pido:** Inser√ß√£o, remo√ß√£o e acesso s√£o r√°pidos.


    - **Opera√ß√µes de Conjunto:** Suporta opera√ß√µes como uni√£o, interse√ß√£o e diferen√ßa (atrav√©s de m√©todos espec√≠ficos).


  - **Uso Comum:**  
    Ideal para armazenar cookies, dados de cache, configura√ß√µes (local storage) ou qualquer modelo chave-valor.


## 2. Implementa√ß√µes Comuns do Map

  - **HashMap:**  


    - Opera√ß√µes de tempo m√©dio O(1) usando tabela hash.

    - N√£o garante ordem dos elementos.  

    - Uso comum quando a performance √© prioridade.


  - **TreeMap:**  


    - Baseado em √°rvore rubro-negra, com opera√ß√µes de tempo O(log n).

    - Armazena os elementos ordenados com base no m√©todo `compareTo` dos objetos ou atrav√©s de um `Comparator` personalizado.


  - **LinkedHashMap:**  


    - Mant√©m a ordem de inser√ß√£o.

    - Performance intermedi√°ria entre HashMap e TreeMap.


## 3. Principais M√©todos do Map

  - **Manipula√ß√£o de pares:**  


    - `put(key, value)` ‚Äì adiciona ou atualiza um par.


    - `remove(key)` ‚Äì remove o par pela chave.


    - `get(key)` ‚Äì retorna o valor associado √† chave.


    - `containsKey(key)` ‚Äì verifica se a chave existe.



  - **Outros m√©todos √∫teis:**  


    - `clear()` ‚Äì remove todos os pares.


    - `size()` ‚Äì retorna a quantidade de elementos.


    - `keySet()` ‚Äì retorna um `Set<K>` com todas as chaves.


    - `values()` ‚Äì retorna uma `Collection<V>` com todos os valores.



  - **Compara√ß√£o:**  
    A igualdade de chaves √© baseada nos m√©todos `equals` e `hashCode`. Se n√£o forem implementados, a compara√ß√£o √© feita via refer√™ncias (ponteiros).


## 4. Como o Map Testa Igualdade

  1. **Se `hashCode` e `equals` estiverem implementados:**  


    - Primeiramente, o Map calcula o `hashCode` para localizar o "balde" adequado.

    - Em seguida, se houver colis√£o (ou seja, hashCodes iguais), o Map usa `equals` para confirmar se as chaves s√£o, de fato, iguais.


  2. **Se `hashCode` e `equals` N√ÉO estiverem implementados:**  


    - A compara√ß√£o √© feita utilizando a compara√ß√£o de refer√™ncias, o que pode levar a resultados inesperados.


## 5. Exemplo L√∫dico üé≤

  Imagine um **dicion√°rio**:


   - **Chaves** s√£o as palavras e **valores** s√£o as defini√ß√µes.


   - Assim como um dicion√°rio n√£o pode ter a mesma palavra duas vezes (duplicidade de chave), um `Map` n√£o permite chaves duplicadas.


   - A busca por uma palavra √© r√°pida, pois o dicion√°rio sabe exatamente onde procurar, assim como um `HashMap` encontra o valor associado √† chave com alta performance.


## 6. Exemplo Pr√°tico üíª

### Demo 1 ‚Äì Uso de TreeMap com Cookies


  ```java
    package application;

    import java.util.Map;
    import java.util.TreeMap;

    public class Program {
        public static void main(String[] args) {
            Map<String, String> cookies = new TreeMap<>();
            cookies.put("username", "maria");
            cookies.put("email", "maria@gmail.com");
            cookies.put("phone", "99771122");
            // Remove o cookie de email
            cookies.remove("email");
            // Atualiza o n√∫mero de telefone
            cookies.put("phone", "99771133");

            System.out.println("Contains 'phone' key: " + cookies.containsKey("phone"));
            System.out.println("Phone number: " + cookies.get("phone"));
            System.out.println("Email: " + cookies.get("email"));
            System.out.println("Size: " + cookies.size());
            System.out.println("ALL COOKIES:");
            for (String key : cookies.keySet()) {
                System.out.println(key + ": " + cookies.get(key));
            }
        }
    }
  ```


### Demo 2 ‚Äì Uso de HashMap com Chaves Personalizadas


  ```java
    package application;

    import java.util.HashMap;
    import java.util.Map;
    import entities.Product;

    public class Program {
        public static void main(String[] args) {
            Map<Product, Double> stock = new HashMap<>();
            Product p1 = new Product("Tv", 900.0);
            Product p2 = new Product("Notebook", 1200.0);
            Product p3 = new Product("Tablet", 400.0);
            stock.put(p1, 10000.0);
            stock.put(p2, 20000.0);
            stock.put(p3, 15000.0);

            // Novo objeto Product com os mesmos atributos de p1
              Product ps = new Product("Tv", 900.0);
              // Resultado depende de equals e hashCode implementados corretamente
              System.out.println("Contains 'ps' key: " + stock.containsKey(ps));
        }
    }
  ```
  

  - **Obs.:** A classe Product deve sobrepor equals e hashCode para que duas inst√¢ncias com mesmo conte√∫do sejam tratadas como iguais.


### Exemplo da classe Product:


  ```java
    package entities;

    public class Product {
        private String name;
        private Double price;
        
        public Product(String name, Double price) {
            this.name = name;
            this.price = price;
        }
        
        // Getters, setters, equals e hashCode
    }
  ```


### Conclus√£o üèÅ

  Map √© uma cole√ß√£o chave-valor onde as chaves s√£o √∫nicas e o acesso √© r√°pido.


  As implementa√ß√µes mais comuns s√£o:


  - **HashMap:** R√°pido e n√£o ordenado.


  - **TreeMap:** Ordenado com base no compareTo do objeto ou um Comparator.


  - **LinkedHashMap:** Mant√©m a ordem de inser√ß√£o.


  A compara√ß√£o das chaves √© feita com base nos m√©todos equals e hashCode.


Domine o uso do Map para criar modelos de dados eficientes e flex√≠veis no desenvolvimento de aplica√ß√µes Java! üòäüöÄ